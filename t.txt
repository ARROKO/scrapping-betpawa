console.log(`\nüìç Test ${i + 1}/${nbMatchs}`);
      console.log(`üéØ Cible: Match num√©ro ${i + 1}`);
      
      // Attendre que les matchs soient visibles
      await page.waitForSelector('[data-test-id="bpEvent"]', { timeout: 10000 });
      
      // R√©cup√©rer tous les matchs disponibles
      const matches = await page.$('[data-test-id="bpEvent"]');
      console.log(`üìä Total de matchs trouv√©s: ${matches.length}`);
      
      if (i >= matches.length) {
        console.log(`‚ö†Ô∏è Plus assez de matchs (demand√©: ${i + 1}, disponible: ${matches.length})`);
        break;
      }
      
      // R√©cup√©rer les informations du match
      const matchInfo = await page.evaluate((index) => {
        const matchElement = document.querySelectorAll('[data-test-id="bpEvent"]')[index];
        if (!matchElement) return null;
        
        const eventId = matchElement.getAttribute('data-event-id');
        const linkElement = matchElement.querySelector('a[href^="/event/"]');
        const href = linkElement ? linkElement.getAttribute('href') : null;
        
        // Essayer de r√©cup√©rer le nom des √©quipes
        const teamElements = matchElement.querySelectorAll('.team-name, .event-name, .participant-name');
        const teamNames = Array.from(teamElements).map(el => el.textContent.trim()).join(' vs ');
        
        return {
          eventId,
          href,
          teamNames: teamNames || `Match ${index + 1}`,
          fullUrl: href ? `https://www.betpawa.cm${href}` : null
        };
      }, i);
      
      if (!matchInfo || !matchInfo.href) {
        console.log(`‚ùå Impossible de r√©cup√©rer les infos du match ${i + 1}`);
        continue;
      }
      
      console.log(`‚öΩ Match: ${matchInfo.teamNames}`);
      console.log(`üÜî Event ID: ${matchInfo.eventId}`);
      console.log(`üîó URL: ${matchInfo.fullUrl}`);
      
      // Cliquer sur le lien du match
      console.log(`üëÜ Clic sur le lien du match...`);
      const matchLink = await matches[i].$('a[href^="/event/"]');
      
      if (matchLink) {
        await matchLink.click();
      
      // Attendre le chargement de la page du match
      console.log(`‚è≥ Attente du chargement (${delai/1000}s)...`);
      await new Promise(resolve => setTimeout(resolve, delai));
      
      // V√©rifier si on est bien sur la page du match
      const isMatchPage = await page.$('.back-button').then(el => !!el).catch(() => false);
      
      if (isMatchPage) {
        console.log(`‚úÖ Navigation r√©ussie vers: ${matchName}`);
        
        // R√©cup√©rer l'URL actuelle pour v√©rification
        const currentUrl = page.url();
        console.log(`üåê URL actuelle: ${currentUrl.substring(0, 60)}...`);
        
        // Cliquer sur le bouton retour
        console.log(`üîô Clic sur le bouton retour...`);
        await page.click('.back-button');
        
        // Attendre le retour √† la liste
        console.log(`‚è≥ Attente du retour (${delai/1000}s)...`);
        await new Promise(resolve => setTimeout(resolve, delai));
        
        // V√©rifier qu'on est bien revenu
        const backToList = await page.$('.event-counter').then(el => !!el).catch(() => false);
        
        if (backToList) {
          console.log(`‚úÖ Retour r√©ussi √† la liste des matchs`);
        } else {
          console.log(`‚ö†Ô∏è Pas s√ªr d'√™tre revenu √† la liste`);
        }
        
      } else {
        console.log(`‚ùå √âchec: Pas arriv√© sur la page du match`);
        
        // Tenter de revenir quand m√™me
        try {
          const backButton = await page.$('.back-button');
          if (backButton) {
            await backButton.click();
            await new Promise(resolve => setTimeout(resolve, delai));
          }
        } catch (e) {
          console.log(`‚ö†Ô∏è Impossible de revenir: ${e.message}`);
        }
      }

      console.log(`‚úÖ Test ${i + 1} termin√©`);
      console.log("-".repeat(30));