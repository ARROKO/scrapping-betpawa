require("dotenv").config();
const puppeteer = require("puppeteer");
const readline = require("readline");

function demanderOption() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    console.log("Choisissez une option :");
    console.log("1. Double chance");
    console.log("2. Juste victoire");
    console.log("3. Plus de 0.5 but");
    rl.question("Votre choix (1-3) : ", (reponse) => {
      rl.close();
      resolve(reponse.trim());
    });
  });
}

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

async function selectDoubleChance(page) {
  try {
    console.log("üîç Recherche des options Double Chance...");
    
    // Attendre que la section Double Chance soit visible
    await page.waitForSelector('[data-test-id="market-4693"]', { timeout: 10000 });
    console.log("‚úÖ Section Double Chance trouv√©e");
    
    // R√©cup√©rer les options double chance avec une approche plus robuste
    const doubleChanceOptions = await page.evaluate(() => {
      const options = [];
      
      // 1X (Domicile ou Match Nul)
      const bet1X = document.querySelector('[data-test-id="Odd-4693-4694"]');
      if (bet1X) {
        const selection = bet1X.querySelector('.event-selection');
        const oddsSpan = bet1X.querySelector('.event-odds span:not(.svg-icon)');
        if (selection && oddsSpan) {
          options.push({
            selector: '[data-test-id="Odd-4693-4694"] .event-bet',
            selection: selection.textContent.trim(),
            odds: parseFloat(oddsSpan.textContent.replace(',', '.'))
          });
        }
      }
      
      // X2 (Match Nul ou Ext√©rieur)
      const betX2 = document.querySelector('[data-test-id="Odd-4693-4695"]');
      if (betX2) {
        const selection = betX2.querySelector('.event-selection');
        const oddsSpan = betX2.querySelector('.event-odds span:not(.svg-icon)');
        if (selection && oddsSpan) {
          options.push({
            selector: '[data-test-id="Odd-4693-4695"] .event-bet',
            selection: selection.textContent.trim(),
            odds: parseFloat(oddsSpan.textContent.replace(',', '.'))
          });
        }
      }
      
      // 12 (Domicile ou Ext√©rieur)
      const bet12 = document.querySelector('[data-test-id="Odd-4693-4696"]');
      if (bet12) {
        const selection = bet12.querySelector('.event-selection');
        const oddsSpan = bet12.querySelector('.event-odds span:not(.svg-icon)');
        if (selection && oddsSpan) {
          options.push({
            selector: '[data-test-id="Odd-4693-4696"] .event-bet',
            selection: selection.textContent.trim(),
            odds: parseFloat(oddsSpan.textContent.replace(',', '.'))
          });
        }
      }
      
      return options;
    });

    if (doubleChanceOptions.length === 0) {
      throw new Error("Aucune option Double Chance trouv√©e");
    }

    console.log(`üìä Options trouv√©es: ${doubleChanceOptions.map(o => `${o.selection} @${o.odds}`).join(', ')}`);

    // Choisir la meilleure option (cote la plus basse = plus s√ªre)
    const bestOption = doubleChanceOptions.reduce((best, current) => 
      current.odds < best.odds ? current : best
    );

    console.log(`üéØ S√©lection: ${bestOption.selection} @${bestOption.odds}`);

    // Cliquer sur la meilleure option
    await page.click(bestOption.selector);
    await delay(2000);

    // V√©rifier que l'option est s√©lectionn√©e
    const isSelected = await page.evaluate((selector) => {
      const element = document.querySelector(selector);
      return element && element.classList.contains('selected');
    }, bestOption.selector);

    if (isSelected) {
      console.log("‚úÖ Option s√©lectionn√©e avec succ√®s !");
      return {
        success: true,
        selection: bestOption.selection,
        odds: bestOption.odds
      };
    } else {
      throw new Error("La s√©lection n'a pas √©t√© prise en compte");
    }

  } catch (error) {
    console.error("‚ùå Erreur lors de la s√©lection:", error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

async function processMatch(page, matchElement) {
  try {
    // R√©cup√©rer l'URL actuelle avant de cliquer
    const initialUrl = page.url();
    console.log(`üåê URL initiale: ${initialUrl}`);
    
    // Ouvrir la page du match
    console.log("üëÜ Clic sur le match...");
    await matchElement.click();
    await delay(3000);

    // V√©rifier qu'on est bien sur une page de match
    const currentUrl = page.url();
    console.log(`üåê URL actuelle: ${currentUrl}`);
    
    if (!currentUrl.includes('/event/')) {
      throw new Error("Pas arriv√© sur la page du match");
    }

    console.log("‚úÖ Page du match charg√©e");

    // S√©lectionner l'option double chance
    const result = await selectDoubleChance(page);
    
    // Revenir √† la liste des matchs - UNE SEULE FOIS
    if (currentUrl !== initialUrl) {
      console.log("üîô Retour √† la liste des matchs...");
      await page.goBack();
      await delay(3000);
      
      // V√©rifier qu'on est bien revenu
      const backUrl = page.url();
      console.log(`üåê URL de retour: ${backUrl}`);
      
      if (backUrl.includes('/event/')) {
        console.log("‚ö†Ô∏è Pas encore revenu, second retour...");
        await page.goBack();
        await delay(2000);
      }
    }

    return result;

  } catch (error) {
    console.error("‚ùå Erreur lors du traitement du match:", error.message);
    
    // En cas d'erreur, v√©rifier si on doit revenir en arri√®re
    const errorUrl = page.url();
    if (errorUrl.includes('/event/')) {
      console.log("üîÑ Tentative de retour apr√®s erreur...");
      try {
        await page.goBack();
        await delay(2000);
      } catch (e) {
        console.error("‚ùå Impossible de revenir:", e.message);
      }
    }
    
    return {
      success: false,
      error: error.message
    };
  }
}

async function safeClickAndPlaceBet(page, targetOdds = 10) {
  let currentTotal = 1;
  let selectedMatches = 0;
  let consecutiveNoMatches = 0;
  const MAX_CONSECUTIVE_NO_MATCHES = 5;
  const usedMatches = new Set(); // Pour √©viter les doublons

  while (currentTotal < targetOdds && consecutiveNoMatches < MAX_CONSECUTIVE_NO_MATCHES) {
    console.log(`\nüî¢ Total actuel: ${currentTotal.toFixed(2)} (Objectif: ${targetOdds})`);
    console.log(`üìä Matchs s√©lectionn√©s: ${selectedMatches}`);

    try {
      // Attendre les matchs visibles
      await page.waitForSelector('.game-event-wrapper', { timeout: 10000 });
      const matches = await page.$$('.game-event-wrapper');
      console.log(`üìã ${matches.length} matchs disponibles`);

      let foundValidMatch = false;

      for (let i = 0; i < matches.length; i++) {
        try {
          // R√©cup√©rer les informations du match
          const matchInfo = await matches[i].evaluate(el => {
            const teams = Array.from(el.querySelectorAll('.scoreboard-participant-name'))
              .map(team => team.textContent.trim());
            const href = el.getAttribute('href');
            return { teams, href };
          });

          const matchKey = `${matchInfo.teams[0]}_vs_${matchInfo.teams[1]}`;
          
          if (usedMatches.has(matchKey)) {
            console.log(`‚è≠Ô∏è Match d√©j√† trait√©: ${matchInfo.teams[0]} vs ${matchInfo.teams[1]}`);
            continue;
          }

          console.log(`\nüîç Analyse: ${matchInfo.teams[0]} vs ${matchInfo.teams[1]}`);

          const result = await processMatch(page, matches[i]);

          if (result.success) {
            currentTotal *= result.odds;
            selectedMatches++;
            foundValidMatch = true;
            usedMatches.add(matchKey);
            
            console.log(`‚úÖ Match s√©lectionn√©! ${result.selection} @${result.odds}`);
            console.log(`üéØ Nouveau total: ${currentTotal.toFixed(2)}`);
            
            // V√©rifier si l'objectif est atteint
            if (currentTotal >= targetOdds) {
              console.log(`üéâ Objectif atteint ! Total: ${currentTotal.toFixed(2)}`);
              break;
            }
            
            break; // Sortir de la boucle des matchs pour recommencer la recherche
          } else {
            usedMatches.add(matchKey); // Marquer comme trait√© m√™me si √©chec
            console.log(`‚ùå √âchec sur: ${matchInfo.teams[0]} vs ${matchInfo.teams[1]}`);
          }
        } catch (error) {
          console.error(`‚ùå Erreur lors de l'analyse du match ${i + 1}:`, error.message);
        }
      }

      if (!foundValidMatch) {
        consecutiveNoMatches++;
        console.log(`üîÑ Aucun match valide trouv√© (${consecutiveNoMatches}/${MAX_CONSECUTIVE_NO_MATCHES})`);
        
        // Si on a √©puis√© les matchs, on peut scroller ou arr√™ter
        if (consecutiveNoMatches >= MAX_CONSECUTIVE_NO_MATCHES) {
          console.log("üõë Arr√™t apr√®s trop d'√©checs cons√©cutifs");
          break;
        }
      } else {
        consecutiveNoMatches = 0;
      }

    } catch (error) {
      console.error("üö® Erreur g√©n√©rale:", error.message);
      consecutiveNoMatches++;
    }
  }

  return {
    success: currentTotal >= targetOdds,
    totalOdds: currentTotal,
    selectedMatches,
    efficiency: ((currentTotal / targetOdds) * 100).toFixed(1)
  };
}

(async () => {
  const choix = await demanderOption();

  const browser = await puppeteer.launch({
    headless: false,
    slowMo: 100,
    args: ['--start-maximized', '--no-sandbox', '--disable-setuid-sandbox']
  });

  const page = await browser.newPage();
  await page.setViewport({ width: 1366, height: 768 });

  console.log("üöÄ Connexion √† BetPawa...");
  await page.goto("https://www.betpawa.cm/", {
    waitUntil: "networkidle2",
    timeout: 30000
  });

  // Cliquer sur "Tout voir Football" si disponible
  try {
    await page.waitForSelector('div.event-counter span.pointer', { timeout: 5000 });
    await page.click('div.event-counter span.pointer');
    console.log('‚úÖ Clic sur "Tout voir Football"');
    await delay(3000);
  } catch {
    console.log('‚ÑπÔ∏è "Tout voir Football" non trouv√© ou d√©j√† sur la page');
  }

  if (choix === "1") {
    console.log("üéØ Strat√©gie: Double chance");
    console.log("üìã Recherche des meilleurs paris Double Chance...\n");
    
    const result = await safeClickAndPlaceBet(page, 10);
    
    console.log("\n" + "=".repeat(50));
    console.log("üìä R√âSULTATS FINAUX");
    console.log("=".repeat(50));
    console.log(`üéØ Objectif: 10x`);
    console.log(`üìà Total atteint: ${result.totalOdds.toFixed(2)}x`);
    console.log(`‚öΩ Matchs s√©lectionn√©s: ${result.selectedMatches}`);
    console.log(`‚úÖ Succ√®s: ${result.success ? 'OUI üéâ' : 'NON ‚ö†Ô∏è'}`);
    console.log(`üìä Efficacit√©: ${result.efficiency}%`);
    console.log("=".repeat(50));
    
    if (result.success) {
      console.log("üéâ F√©licitations ! Objectif atteint !");
    } else {
      console.log("‚ö†Ô∏è Objectif non atteint, mais des paris ont √©t√© s√©lectionn√©s.");
    }
  } else {
    console.log("‚ö†Ô∏è Seule l'option 1 (Double chance) est impl√©ment√©e");
  }

  console.log("\nüí° Navigateur ouvert pour inspection - Appuyez sur Ctrl+C pour fermer");
  // await browser.close();
})();